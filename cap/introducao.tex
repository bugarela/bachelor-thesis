\chapter{Introdução}
\label{introducao}

Desde a década de 60, com os trabalhos de Floyd e Hoare, são feitos trabalhos com propostas para especificar software formalmente. Com especificações, o grau de confiança na correção do programa aumenta, e se torna possível provar formalmente algumas propriedades, com base na semântica da especificação.

Esses trabalhos, contudo, são direcionados a programas sequenciais. Especificar um software concorrente necessita uma modelagem diferente, e não era possível até os primeiros trabalhos de Leslie Lamport na década de 90.

Os métodos de especificação mais bem sucedidos são baseados em modelar transformações de estados com alguma lógica formal. Pensando em sistemas concorrentes, Lamport propõe uma lógica que estende os termos básicos da lógica temporal para permitir predicados sobre pares de estados, o que ele chama de ações. Essa abstração permite manipular ações e não o sistema temporal puro. Essa lógica é chamada de TLA - \textit{Temporal Logic of Actions}.

Sistemas concorrentes são aqueles onde mais de uma computação acontece no mesmo intervalo de tempo - concorrentemente - podendo ou não interagir entre si. Na lógica temporal, os passos executados por todas essas computações concorrentes são descritos como um comportamento, e definidos por uma sequência infinita de estados. Assim, uma fórmula da lógica pode ser verdadeira ou falsa para um comportamento, assim como pode ser válida ou não para todos os comportamentos possíveis.

Com essa abordagem, é possível verificar propriedades sobre um sistema especificado. Especificar um sistema significa definir todos os seus comportamentos possíveis. Tratando-se de um sistema concorrente, é esperado que existam muitos comportamentos, e listá-los exaustivamente seria uma tarefa extremamente passível de erro. Para viabilizar a definição dos comportamentos, é empregada uma modelagem semelhante a de uma máquina de estados, onde é definida a fórmula para o estado inicial e as fórmulas para as transições.

Baseando-se na lógica definida como TLA, Lamport propõe a linguagem de especificação formal \TLA (\textit{Temporal Logic of Actions}), com o objetivo de escrever provas formais para sistemas concorrentes da maneira mais simples possível~\cite{tlahistory}. Nessa linguagem, além dos operadores de TLA, são incluídos elementos da teoria de conjuntos e alguns açúcares sintáticos para fórmulas temporais como cláusulas \IF e \textsc{case}.

No viés de permitir verificações de propriedades, surge o \textit{model checker} TLC. Um \textit{model checker} busca todos os estados atingíveis de um modelo, de forma que todos os comportamentos possíveis são verificados. O TLC recebe uma especificação e uma configuração, e verifica se as fórmulas temporais dadas são válidas para a especificação. Se nenhuma fórmula temporal for dada, o TLC checará a presença de erros na semântica de \TLA e de situações de \textit{deadlock}. A checagem de \textit{deadlock} pode ser desativada, já que pode significar terminação em alguns sistemas.

Mais recentemente, outra ferramenta para verificar propriedades de uma especificação está em desenvolvimento: o sistema de provas TLAPS (\textit{TLA Proof System}) \cite{tlaps2010}. Esse sistema permite checar mecanicamente algumas provas, semelhantemente a Coq e Isabelle, mas ainda está incompleto.

A partir das definições de propriedades desejadas e da possibilidade de verificá-las, se torna possível alterar uma especificação no intuito de buscar por otimizações ou propostas diferentes para o sistema e, através das verificações, encontrar potenciais problemas como \textit{bugs} e inconsistências com as propriedades exigidas. Esses benefícios foram reportados pela \textit{Amazon Web Services} ~\cite{amazon}, que afirma ter usado \TLA em 10 sistemas complexos e, para cada um deles, ter encontrado \textit{bugs} ou adquirido entendimento e confiança para implementar otimizações agressivas.

As especificações formais escritas, contudo, não possuem nenhum vínculo com a implementação em uma lógica de programação. O elo que correlaciona as duas partes é limitado ao entendimento do programador que as escreveu. Outras linguagens de especificação formal com objetivos semelhantes ao \TLA, como Z, B-Method e ASM, fornecem formas de gerar código a partir do modelo. Contudo, até a data da escrita desse texto, não foram encontrados geradores de código a partir de modelos escritos em \TLA, impossibilitando a conversão das especificações em linguagens de programação com garantia de correspondência.

Observações sobre os benefícios da geração de código a partir de modelos de especificação formal já foram verificadas em trabalhos como o estudo de caso em \cite{Leonard2008}. Práticas da engenharia de software vem tentado buscar maneiras de minimizar a geração de \textit{bugs} por erro humano. Técnicas de revisão de código, programação em pares e examinadores automáticos de código são formas de detectar erros e quebra de certas propriedades. Práticas como essa são precedidas de uma fase de desenho de solução, onde podem ser feitos documentos e protótipos antes de uma implementação em linguagem de programação. Atualmente, a fase de desenho poderia ser feita formalmente, descrevendo a solução em \TLA. Já a minimização de erros não tem benefícios, uma vez que a tradução do desenho para o código ainda seria feita por um humano e estaria sujeita a erros.

A motivação para automatizar esse processo é mitigar erros humanos na tradução de um desenho formalmente verificado para um código em linguagem de programação. Com o programa especificado, validado e traduzido, é possível aplicá-lo diretamente em casos reais com uma garantia de correspondência maior, assegurando as propriedades verificadas. A partir deste código gerado, ainda são permitidas modificações, como para melhorar a implementação em busca de uma versão mais otimizada. Essa nova versão estará partindo de uma base verificada e recebendo possivelmente novos comportamentos que não foram verificados - nesse caso, a garantia é reduzida, já que as mudanças não estavam representadas no modelo original.

\section{Objetivos}

Esse trabalho é feito com a intenção de elaborar um método de tradução, através do mapeamento de estruturas e construtores, de especificações formais descritas em \TLA para código em linguagem de programação com possibilidade de ser executado e modificado; assim como implementar um tradutor que aplique esse método.

\subsection{Objetivos Específicos}
\begin{itemize}
  \item Encontrar mapeamentos entre as estruturas de especificação em \TLA e estruturas de linguagens de programação
  \item Implementar um gerador de código Elixir, com capacidade de fazer \textit{parsing} de especificações em \TLA e aplicar os mapeamentos necessários.
\end{itemize}
